import scrape_swingtradebot as stb
import alphavantage_api as av
import analysis as an
import pandas as pd
import argparse


def scrape_driver(overwrite, max_page_num):
    """
    calls the scraper functions from swingtradebot.py (which will also call yahoo finance scrape functions)
    :param overwrite: if the user wants to overwrite the current data
    :param max_page_num: page number to stop at (each swingtradebot.com page has 20 symbols)
    :return: a list of symbols to process, and a pandas DataFrame containing all the information scraped
    """
    symbols_from_scrape = stb.swingtradebot_driver(overwrite, max_page_num)
    scraped_df = pd.DataFrame(symbols_from_scrape).T.reset_index()
    scraped_df = scraped_df.drop(columns=["index"])
    return list(symbols_from_scrape.keys()), scraped_df


def local_driver():
    """
    collects data from local CSV files and generates pandas DataFrames
    :return: pandas DataFrames containing information from symbols.csv and ninety_day_historical_prices.csv
    """
    # now we have the CSV
    try:
        tmp = open('symbols.csv', mode='r', encoding="utf-8")
        tmp.close()
    except PermissionError as e:
        print(f'symbols.csv is locked. Please unlock or close the file before rerunning. {e}')
        exit()
    except FileNotFoundError as fnf:
        print(f'symbols.csv does not exist in the current directory. Please verify it exists in the current directory. '
              f'Ending program.')
        exit()
    else:
        sym_df = pd.read_csv('symbols.csv')
        print('Successfully read symbols.csv')

        try:
            tmp = open('ninety_day_historical_prices.csv', mode='r', encoding="utf-8")
            tmp.close()
        except PermissionError as e:
            print(f'ninety_day_historical_prices.csv is locked. Please unlock or close the file before rerunning. {e} ')
            exit()
        except FileNotFoundError as fnf:
            print(f'ninety_day_historical_prices.csv does not exist in the current directory. '
                  f'Please verify it exists in the current directory. Ending program.')
            exit()
        else:
            prices_df = pd.read_csv('ninety_day_historical_prices.csv')
            print('Successfully read ninety_day_historical_prices.csv')
            return sym_df, prices_df


def main():
    """
    user can determine whether to take data from remote (remote or test) or local files
    user can determine whether to overwrite data collected and image generated.
    :return: nothing is returned
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('-source', type=str, required=True,
                        help='Valid entries are "local", "remote", or "test". "local" will use the local CSV files '
                             'and assumes that they are of the correct format. "remote" will scrape websites and use '
                             'the Alphavantage API to collect the data (this will take approximately 45-50 minutes). '
                             '"test" will be the same as remote with the exception of pulling only 1 page and'
                             ' processing 20 symbols instead of 200 (takes 5-6 minutes).')
    parser.add_argument('-overwrite', type=int, required=False, default=0,
                        help='"1" for True/Yes, anything else for False/No. "Yes" will overwrite CSV files (if '
                             'remote/test is chosen for source) and image generated by the program with updated data. '
                             '"No" will only generate the results from current data but leave the files in their '
                             'current state. If not included as an argument, program will default as False/No. You '
                             'must choose "-overwrite=1" to generate the files if they do not already exist.')
    args, unknown = parser.parse_known_args()

    if args.overwrite == 1:
        overwrite = True
    else:
        overwrite = False

    if args.source.strip() == 'remote':
        print(
            f'Overwrite setting is {overwrite}. If you did not enter an overwrite setting, the program defaults to '
            f'False. This means the current files will not be touched (if they exist). To see more, run the program '
            f'with -h.')
        page_to_stop = 11
        symbols, symbol_df = scrape_driver(overwrite, page_to_stop)
        prices_df = av.alphavantage_driver(symbols, overwrite, page_to_stop)
        print('Running analysis now')
        an.analysis_driver(symbol_df, prices_df, overwrite)
        print('End of program.\n--------')

    elif args.source.strip() == 'local':
        print(
            f'Overwrite setting is {overwrite}. If you did not enter an overwrite setting, the program defaults to '
            f'False. This means the current files will not be touched (if they exist). To see more, run the program '
            f'with -h.')
        # generate dataframes from local files
        print('Calling local driver. ')
        symbol_df, prices_df = local_driver()

        # analyze from dataframes
        print('Running analysis now')
        an.analysis_driver(symbol_df, prices_df, overwrite)
        print('End of program.\n--------')

    elif args.source.strip() == 'test':
        print(
            f'Overwrite setting is {overwrite}. If you did not enter an overwrite setting, the program defaults to '
            f'False. This means the current files will not be touched (if they exist). To see more, run the program '
            f'with -h.')
        page_to_stop = 2
        symbols, symbol_df = scrape_driver(overwrite, page_to_stop)
        prices_df = av.alphavantage_driver(symbols, overwrite, page_to_stop)
        print('Running analysis now')
        an.analysis_driver(symbol_df, prices_df, overwrite)
        print('End of program.\n--------')

    else:
        print('Invalid arguments. Please rerun program with "-source=local", "-source=remote" or "-source=test". No '
              'spaces in between the dash or equal sign.')


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("User interrupted (Ctrl + C). Ended program.")
        exit()
